<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nancy&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-11T04:37:57.134Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Nancy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法训练1</title>
    <link href="http://example.com/2023/08/11/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%831/"/>
    <id>http://example.com/2023/08/11/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%831/</id>
    <published>2023-08-11T03:14:00.000Z</published>
    <updated>2023-08-11T04:37:57.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法训练1——栈"><a href="#算法训练1——栈" class="headerlink" title="算法训练1——栈"></a>算法训练1——栈</h1><h2 id="栈的基础知识"><a href="#栈的基础知识" class="headerlink" title="栈的基础知识"></a>栈的基础知识</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ol><li>栈（又名：堆栈）是一种只能在一段进行插入或删除操作的线性表（受限的线性表）</li><li>特点：先进后出 （注意：这点与队列不同，队列是先进先出，可以想象成排队）</li></ol><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><pre><code>1. 栈顶  (Top)：（进出口）表中允许进行插入或删除操作的一端2. 栈底 (Bottom):栈顶和栈底是相对而言的，一端被称作为栈顶，相对的，另一端就被称作为栈底。3. 进栈/入栈（Push）：栈的插入操作。4. 出栈/退栈（Pop）：栈的删除操作。5. 空栈：栈中没有元素/(s-&gt;Top==-1;)6. 满栈：栈中已放满元素/(s-&gt;Top==MaxSize-1)     </code></pre><blockquote><p>注意：栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）        </p></blockquote><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>–此时可做 leetcode 的题目<br><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><p>–以下是按照卡哥教的方法写的代码</p><p>代码测试（Java）：</p><pre><code class="java">class MyQueue &#123;    Stack&lt;Integer&gt; stackIn;    Stack&lt;Integer&gt; stackout;    public MyQueue() &#123;        stackIn = new Stack&lt;&gt;();        stackout = new Stack&lt;&gt;();    &#125;    public void push(int x) &#123;        stackIn.push(x);    &#125;    public int pop() &#123;        dump();        return stackout.pop();    &#125;    public int peek() &#123;        dump();        return stackout.peek();    &#125;    public boolean empty() &#123;        return stackIn.isEmpty() &amp;&amp; stackout.isEmpty();    &#125;    private void dump()&#123;        if(!stackout.isEmpty())&#123;            return;        &#125;        while (!stackIn.isEmpty())&#123;            stackout.push(stackIn.pop());        &#125;    &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */</code></pre><p>–思考：用栈模拟队列，此方法是用两个栈来放，一个放进栈的元素，一个放出栈的元素。自定义一个函数，判断目前要包含出栈元素的栈是否为空，不为空则返回，将里面的元素弹出，当为空时，进入while循环，判断包含入栈元素的栈是否为空，若不为空，则将栈顶元素弹出逐步放入出栈，最后在出栈那里实现队列。</p><h2 id="判断括号是否有序合法"><a href="#判断括号是否有序合法" class="headerlink" title="判断括号是否有序合法"></a>判断括号是否有序合法</h2><p>–此时可做 leetcode 的题目<br><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>–以下是按照卡哥教的方法写的代码</p><p>代码测试（Java）：</p><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();        char ch;        for(int i=0;i&lt;s.length();i++)&#123;            ch = s.charAt(i);            if(ch==&#39;(&#39;)&#123;                deque.push(&#39;)&#39;);            &#125; else if (ch==&#39;&#123;&#39;) &#123;                deque.push(&#39;&#125;&#39;);            &#125; else if (ch==&#39;[&#39;) &#123;                deque.push(&#39;]&#39;);            &#125; else if (deque.isEmpty() || deque.peek()!=ch) &#123;                return false;            &#125;else &#123;                deque.pop();            &#125;        &#125;        return deque.isEmpty();    &#125;&#125;</code></pre><p>–原先的解法：</p><p>代码测试（Java）：</p><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        if(s.length()%2!=0)&#123;            return false;        &#125;        Map&lt;Character, Character&gt; pairs = new HashMap&lt;Character, Character&gt;() &#123;&#123;            put(')', '(');            put(']', '[');            put('&#125;', '&#123;');        &#125;&#125;;        Deque&lt;Character&gt; stack = new LinkedList&lt;Character&gt;();        for (int i = 0; i &lt; s.length(); i++) &#123;            char ch = s.charAt(i);            if (pairs.containsKey(ch)) &#123;                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;                    return false;                &#125;                stack.pop();            &#125; else &#123;                stack.push(ch);            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre><p>–思考：</p><blockquote><p>解法一：原先使用HashMap,使用键和值相对，当字符串长度不是偶数，那绝对不合法，直接返回。然后用左括号和右括号相对的放入HashMap。再定义一个双向队列，遍历字符串，当遇到一个左括号，即搜索HashMap中有无相对应的key，若有，则判断此时栈中是否有为空，若栈中为空，证明无配对，返回false；或者栈中第一个不是HashMap中能与此时的左括号相对应的右括号，也返回false。若HashMap中没有相对应的key，则证明是右括号，则将他放入栈。最后返回栈是否为空，若为空则配对完成，若不为空，则存在多余的或者不合法的括号。</p></blockquote><blockquote><p>–解法二：直接使用双向队列，遇到左括号，就把相应的右括号放进队列，若遇到右括号，则判断此时队列是否为空或者此时的队列的元素跟现在的这个元素不相等，就返回false，若相等，就把队列的元素弹出。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法训练1——栈&quot;&gt;&lt;a href=&quot;#算法训练1——栈&quot; class=&quot;headerlink&quot; title=&quot;算法训练1——栈&quot;&gt;&lt;/a&gt;算法训练1——栈&lt;/h1&gt;&lt;h2 id=&quot;栈的基础知识&quot;&gt;&lt;a href=&quot;#栈的基础知识&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/08/04/hello-world/"/>
    <id>http://example.com/2023/08/04/hello-world/</id>
    <published>2023-08-04T03:20:17.788Z</published>
    <updated>2023-08-04T03:20:17.788Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
